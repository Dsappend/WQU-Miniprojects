In this problem we will develop an even faster method which is known as the Sieve of Eratosthenes (although it will be more expensive in terms of memory). The Sieve of Eratosthenes is an example of dynamic programming, where the general idea is to not redo computations we have already done (read more about it here). We will break this sieve down into several small functions.

Our submission will be a list of all prime numbers less than 2000.

The method works as follows (see here for more details)

    Generate a list of all numbers between 0 and N; mark the numbers 0 and 1 to be not prime
    Starting with 𝑝=2

(the first prime) mark all numbers of the form 𝑛𝑝 where 𝑛>1 and 𝑛𝑝<=𝑁
to be not prime (they can't be prime since they are multiples of 2!)
Find the smallest number greater than 𝑝
which is not marked and set that equal to 𝑝, then go back to step 2. Stop if there is no unmarked number greater than 𝑝 and less than 𝑁+1

We will break this up into a few functions, our general strategy will be to use a Python list as our container although we could use other data structures. The index of this list will represent numbers.

We have implemented a sieve function which will find all the prime numbers up to 𝑛

. You will need to implement the functions which it calls. They are as follows

    list_true Make a list of true values of length 𝑛+1

where the first two values are false (this corresponds with step 1 of the algorithm above)
mark_false takes a list of booleans and a number 𝑝
. Mark all elements 2𝑝,3𝑝,...𝑛
false (this corresponds with step 2 of the algorithm above)
find_next Find the smallest True element in a list which is greater than some 𝑝
(has index greater than 𝑝

    (this corresponds with step 3 of the algorithm above)
    prime_from_list Return indices of True values

Remember that python lists are zero indexed. We have provided assertions below to help you assess whether your functions are functioning properly.

def list_true(n):

    prime = [True for i in range(n+1)]

    prime[0] = False

    prime[1] = False

    

    return prime

assert len(list_true(20)) == 21

assert list_true(20)[0] is False

assert list_true(20)[1] is False

Now we want to write a function which takes a list of elements and a number 𝑝
and marks elements false which are in the range 2𝑝,3𝑝...𝑁

.

def mark_false(bool_list, p):

    k = len(bool_list)

    for i in range(2*p, k, p):

        bool_list[i] = False

    return bool_list

assert mark_false(list_true(6), 2) == [False, False, True, True, False, True, False]

Now lets write a find_next function which returns the smallest element in a list which is not false and is greater than 𝑝

.

def find_next(bool_list, p):

    k = len(bool_list)

    for i in range(p+1,k):

        if bool_list[i]:

            return i

    return None

assert find_next([True, True, True, True], 2) == 3

assert find_next([True, True, True, False], 2) is None

Now given a list of True and False, return the index of the true values.

def prime_from_list(bool_list):

    prime_true_index_list = []

    

    for i in range(len(bool_list)):

        

        if bool_list[i] == True:

            prime_true_index_list.append(i)

    

    return prime_true_index_list

assert prime_from_list([False, False, True, True, False]) ==  [2, 3]

def sieve(n):

    bool_list = list_true(n)

    p = 2

    while p is not None:

        bool_list = mark_false(bool_list, p)

        p = find_next(bool_list, p)

    return prime_from_list(bool_list)

assert sieve(1000) == get_primes(0,1000)

---------------------------------------------------------------------------
AssertionError                            Traceback (most recent call last)
<ipython-input-38-e3acdae3d384> in <module>()
----> 1 assert sieve(1000) == get_primes(0,1000)

AssertionError: 

%%timeit 

sieve(1000)

392 µs ± 2.45 µs per loop (mean ± std. dev. of 7 runs, 1000 loops each)

%%timeit 

get_primes(0, 1000)

694 ns ± 10.4 ns per loop (mean ± std. dev. of 7 runs, 1000000 loops each)
